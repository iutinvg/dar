<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0056)http://wiki.apache.org/couchdb/Replication_and_conflicts -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="robots" content="index,nofollow">

<title>Replication_and_conflicts - Couchdb Wiki</title>
<script type="text/javascript" src="./Replication_and_conflicts - Couchdb Wiki_files/common.js"></script><style type="text/css"></style>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="./Replication_and_conflicts - Couchdb Wiki_files/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="./Replication_and_conflicts - Couchdb Wiki_files/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="./Replication_and_conflicts - Couchdb Wiki_files/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="./Replication_and_conflicts - Couchdb Wiki_files/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/wiki/modernized/css/msie.css">
<![endif]-->


<link rel="alternate" title="Couchdb Wiki: Replication_and_conflicts" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?diffs=1&show_att=1&action=rss_rc&unique=0&page=Replication_and_conflicts&ddiffs=1" type="application/rss+xml">


<link rel="Start" href="http://wiki.apache.org/couchdb/FrontPage">
<link rel="Alternate" title="Wiki Markup" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=raw">
<link rel="Alternate" media="print" title="Print View" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=print">
<link rel="Search" href="http://wiki.apache.org/couchdb/FindPage">
<link rel="Index" href="http://wiki.apache.org/couchdb/TitleIndex">
<link rel="Glossary" href="http://wiki.apache.org/couchdb/WordIndex">
<link rel="Help" href="http://wiki.apache.org/couchdb/HelpOnFormatting">
</head>

<body lang="en" dir="ltr">

<div id="header">

<form id="searchform" method="get" action="./Replication_and_conflicts - Couchdb Wiki_files/Replication_and_conflicts - Couchdb Wiki.html">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput" style="display: none;">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20" onfocus="searchFocus(this)" onblur="searchBlur(this)" onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search" class="disabled">
<input id="titlesearch" name="titlesearch" type="submit" value="Titles" alt="Search Titles" disabled="">
<input id="fullsearch" name="fullsearch" type="submit" value="Text" alt="Search Full Text" disabled="">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<div id="logo"><a href="http://wiki.apache.org/couchdb/FrontPage">Couchdb Wiki</a></div>
<div id="username"><a href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=login" id="login" rel="nofollow">Login</a></div>
<h1 id="locationline">

<span id="pagelocation"><a class="backlink" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=fullsearch&value=linkto%3A%22Replication_and_conflicts%22&context=180" rel="nofollow" title="Click to do a full-text search for this title">Replication_and_conflicts</a></span>
</h1>


<ul id="navibar">
<li class="wikilink"><a href="http://wiki.apache.org/couchdb/FrontPage">FrontPage</a></li><li class="wikilink"><a href="http://wiki.apache.org/couchdb/RecentChanges">RecentChanges</a></li><li class="wikilink"><a href="http://wiki.apache.org/couchdb/FindPage">FindPage</a></li><li class="wikilink"><a href="http://wiki.apache.org/couchdb/HelpContents">HelpContents</a></li><li class="current"><a href="./Replication_and_conflicts - Couchdb Wiki_files/Replication_and_conflicts - Couchdb Wiki.html">Replication_and_conflicts</a></li>
</ul>

<div id="pageline"><hr style="display:none;"></div>

<ul class="editbar"><li><span class="disabled">Immutable Page</span></li><li class="toggleCommentsButton" style="display:none;"><a href="http://wiki.apache.org/couchdb/Replication_and_conflicts#" class="nbcomment" onclick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="./Replication_and_conflicts - Couchdb Wiki_files/Replication_and_conflicts - Couchdb Wiki.html">
<div>
    
    <select name="action" onchange="if ((this.selectedIndex != 0) &amp;&amp;
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="show">More Actions:</option><option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="RenderAsDocbook">Render as Docbook</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="RenamePage" disabled="" class="disabled">Rename Page</option>
<option value="CopyPage">Copy Page</option>
<option value="DeletePage" disabled="" class="disabled">Delete Page</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="MyPages">My Pages</option>
<option value="show" disabled="" class="disabled">Subscribe User</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="show" disabled="" class="disabled">Remove Spam</option>
<option value="show" disabled="" class="disabled">Revert to this revision</option>
<option value="PackagePages">Package Pages</option>
<option value="SyncPages">Sync Pages</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="Load">Load</option>
<option value="Save">Save</option>
<option value="SlideShow">SlideShow</option>
    </select>
    
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867"></p><div dir="ltr" id="EditTheWiki.content" lang="en"><span class="anchor" id="EditTheWiki.top"></span>
<span class="anchor" id="EditTheWiki.line-1"></span><span class="anchor" id="EditTheWiki.line-2"></span><span class="anchor" id="EditTheWiki.line-3"></span><div><table><tbody><tr>  <td style="background-color: #efefef"><p class="line862">We have a <a class="https" href="https://cwiki.apache.org/confluence/display/COUCHDB/Apache+CouchDB+Wiki">new wiki</a>. The migration is not 100% complete. You can help out by moving pages across. This wiki will exist for as long as there are pages left.</p></td>
</tr>
</tbody></table></div><span class="anchor" id="EditTheWiki.line-4"></span><span class="anchor" id="EditTheWiki.line-5"></span><div><table><tbody><tr>  <td style="background-color: #efefef"><p class="line862">The official documentation has moved to <a class="http" href="http://docs.couchdb.org/">http://docs.couchdb.org</a> â€” The transition is not 100% complete, but <a class="http" href="http://docs.couchdb.org/">http://docs.couchdb.org</a> should be seen as having the latest info. In some cases, the wiki still has some more or older info on certain topics inside CouchDB.</p></td>
</tr>
</tbody></table></div><span class="anchor" id="EditTheWiki.line-6"></span><span class="anchor" id="EditTheWiki.line-7"></span><div><table><tbody><tr>  <td style="background-color: #efefef"><p class="line891"><small>You need to be added to the <a href="http://wiki.apache.org/couchdb/ContributorsGroup">ContributorsGroup</a> to edit the wiki. But don't worry! Just email any <a class="http" href="http://wiki.apache.org/couchdb/Mailing%20lists">Mailing List</a> or grab us on <a class="irc" href="irc://irc.freenode.net/couchdb">IRC</a> and let us know your user name.</small></p></td>
</tr>
</tbody></table></div><span class="anchor" id="EditTheWiki.line-8"></span><span class="anchor" id="EditTheWiki.bottom"></span></div> <span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line867">
</p><h1 id="Replication_and_conflict_model">Replication and conflict model</h1>
<span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line874">Let's take the following example to illustrate replication and conflict <span class="anchor" id="line-6"></span>handling. <span class="anchor" id="line-7"></span><span class="anchor" id="line-8"></span></p><ul><li>Alice has a document containing Bob's business card <span class="anchor" id="line-9"></span></li><li>She synchronizes it between her desktop PC and her laptop <span class="anchor" id="line-10"></span></li><li>On the desktop PC, she updates Bob's E-mail address. Without <span class="anchor" id="line-11"></span>syncing again, she updates Bob's mobile number on the laptop. <span class="anchor" id="line-12"></span></li><li>Then she replicates the two to each other again <span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span></li></ul><p class="line874">So on the desktop the document has Bob's new E-mail address and his old mobile number, and on the laptop it has his old E-mail address and his new mobile number. <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span></p><p class="line874">The question is, what happens to these conflicting updated documents? <span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span></p><p class="line867">
</p><h2 id="CouchDB_replication">CouchDB replication</h2>
<span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span><p class="line874">CouchDB works with JSON documents inside databases.  Replication of <span class="anchor" id="line-21"></span>databases takes place over HTTP, and can be either a "pull" or a "push", but <span class="anchor" id="line-22"></span>is unidirectional.  So the easiest way to perform a full sync is to do a <span class="anchor" id="line-23"></span>"push" followed by a "pull" (or vice versa). <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span></p><p class="line874">So, Alice creates v1 and sync it. She updates to v2a on one side and v2b on <span class="anchor" id="line-26"></span>the other, and then replicates. What happens? <span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span></p><p class="line862">The answer is simple: <em>both</em> versions exist on both sides! <span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span></p><p class="line867"><span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span></p><pre><span class="anchor" id="line-1"></span>     DESKTOP                          LAPTOP
<span class="anchor" id="line-2"></span>   +---------+
<span class="anchor" id="line-3"></span>   | /db/bob |                                     INITIAL
<span class="anchor" id="line-4"></span>   |   v1    |                                     CREATION
<span class="anchor" id="line-5"></span>   +---------+
<span class="anchor" id="line-6"></span>
<span class="anchor" id="line-7"></span>   +---------+                      +---------+
<span class="anchor" id="line-8"></span>   | /db/bob |  -----------------&gt;  | /db/bob |     PUSH
<span class="anchor" id="line-9"></span>   |   v1    |                      |   v1    |
<span class="anchor" id="line-10"></span>   +---------+                      +---------+
<span class="anchor" id="line-11"></span>
<span class="anchor" id="line-12"></span>   +---------+                      +---------+  INDEPENDENT
<span class="anchor" id="line-13"></span>   | /db/bob |                      | /db/bob |     LOCAL
<span class="anchor" id="line-14"></span>   |   v2a   |                      |   v2b   |     EDITS
<span class="anchor" id="line-15"></span>   +---------+                      +---------+
<span class="anchor" id="line-16"></span>
<span class="anchor" id="line-17"></span>   +---------+                      +---------+
<span class="anchor" id="line-18"></span>   | /db/bob |  -----------------&gt;  | /db/bob |     PUSH
<span class="anchor" id="line-19"></span>   |   v2a   |                      |   v2a   |
<span class="anchor" id="line-20"></span>   +---------+                      |   v2b   |
<span class="anchor" id="line-21"></span>                                    +---------+
<span class="anchor" id="line-22"></span>
<span class="anchor" id="line-23"></span>   +---------+                      +---------+
<span class="anchor" id="line-24"></span>   | /db/bob |  &lt;-----------------  | /db/bob |     PULL
<span class="anchor" id="line-25"></span>   |   v2a   |                      |   v2a   |
<span class="anchor" id="line-26"></span>   |   v2b   |                      |   v2b   |
<span class="anchor" id="line-27"></span>   +---------+                      +---------+</pre><span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line874">After all, this is not a filesystem, so there's no restriction that only one <span class="anchor" id="line-61"></span>document can exist with the name /db/bob. These are just "conflicting" <span class="anchor" id="line-62"></span>revisions under the same name. <span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span></p><p class="line874">Because the changes are always replicated, the data is safe. Both machines <span class="anchor" id="line-65"></span>have identical copies of both documents, so failure of a hard drive on <span class="anchor" id="line-66"></span>either side won't lose any of the changes. <span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span></p><p class="line874">Another thing to notice is that peers do not have to be configured or <span class="anchor" id="line-69"></span>tracked.  You can do regular replications to peers, or you can do one-off, <span class="anchor" id="line-70"></span>ad-hoc pushes or pulls.  After the replication has taken place, there is no <span class="anchor" id="line-71"></span>record kept of which peer any particular document or revision came from. <span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span></p><p class="line874">So the question now is: what happens when you try to read /db/bob? By <span class="anchor" id="line-74"></span>default, CouchDB picks one arbitrary revision as the "winner", using a <span class="anchor" id="line-75"></span>deterministic algorithm so that the same choice will be made on all peers. <span class="anchor" id="line-76"></span>The same happens with views: the deterministically-chosen winner is the only <span class="anchor" id="line-77"></span>revision fed into your map function. <span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span></p><p class="line874">Let's say that the winner is v2a. On the desktop, if Alice reads the <span class="anchor" id="line-80"></span>document she'll see v2a, which is what she saved there. But on the laptop, <span class="anchor" id="line-81"></span>after replication, she'll also see only v2a. It could look as if the changes <span class="anchor" id="line-82"></span>she made there have been lost - but of course they have not, they have just <span class="anchor" id="line-83"></span>been hidden away as a conflicting revision. But eventually she'll need these <span class="anchor" id="line-84"></span>changes merged into Bob's business card, otherwise they <em>will</em> effectively <span class="anchor" id="line-85"></span>have been lost. <span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span></p><p class="line874">Any sensible business-card application will, at minimum, have to present the <span class="anchor" id="line-88"></span>conflicting versions to Alice and allow her to create a new version <span class="anchor" id="line-89"></span>incorporating information from them all. Ideally it would merge the updates <span class="anchor" id="line-90"></span>itself. <span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span></p><p class="line867">
</p><h2 id="Conflict_avoidance">Conflict avoidance</h2>
<span class="anchor" id="line-93"></span><span class="anchor" id="line-94"></span><p class="line874">When working on a single node, CouchDB will avoid creating conflicting <span class="anchor" id="line-95"></span>revisions by returning a 409 HTTP error.  This is because, when you PUT a <span class="anchor" id="line-96"></span>new version of a document, you must give the _rev of the previous version.  <span class="anchor" id="line-97"></span>If that _rev has already been superceded, the update is rejected with a 409. <span class="anchor" id="line-98"></span><span class="anchor" id="line-99"></span></p><p class="line874">So imagine two users on the same node are fetching Bob's business card, <span class="anchor" id="line-100"></span>updating it concurrently, and writing it back: <span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span></p><p class="line867"><span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span></p><pre><span class="anchor" id="line-1-1"></span>USER1    -----------&gt;  GET /db/bob
<span class="anchor" id="line-2-1"></span>         &lt;-----------  {"_rev":"1-aaa", ...}
<span class="anchor" id="line-3-1"></span>
<span class="anchor" id="line-4-1"></span>USER2    -----------&gt;  GET /db/bob
<span class="anchor" id="line-5-1"></span>         &lt;-----------  {"_rev":"1-aaa", ...}
<span class="anchor" id="line-6-1"></span>
<span class="anchor" id="line-7-1"></span>USER1    -----------&gt;  PUT /db/bob?rev=1-aaa
<span class="anchor" id="line-8-1"></span>         &lt;-----------  {"_rev":"2-bbb", ...}
<span class="anchor" id="line-9-1"></span>
<span class="anchor" id="line-10-1"></span>USER2    -----------&gt;  PUT /db/bob?rev=1-aaa
<span class="anchor" id="line-11-1"></span>         &lt;-----------  409 Conflict  (not saved)</pre><span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><p class="line874">User2's changes are rejected, so it's up to the app to fetch /db/bob again, <span class="anchor" id="line-117"></span>and either: <span class="anchor" id="line-118"></span></p><ul><li>apply the same changes as were applied to the earlier revision, and <span class="anchor" id="line-119"></span>submit a new PUT <span class="anchor" id="line-120"></span></li><li>redisplay the document so the user has to edit it again <span class="anchor" id="line-121"></span></li><li>just overwrite it with the document being saved before (which is not <span class="anchor" id="line-122"></span>advisable, as user1's changes will be silently lost) <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span></li></ul><p class="line874">So when working in this mode, your application still has to be able to <span class="anchor" id="line-125"></span>handle these conflicts and have a suitable retry strategy, but these <span class="anchor" id="line-126"></span>conflicts never end up inside the database itself. <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span></p><p class="line867">
</p><h2 id="Conflicts_in_batches">Conflicts in batches</h2>
<span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><p class="line874">There are two different ways that conflicts can end up in the database: <span class="anchor" id="line-131"></span></p><ol type="1"><li>Conflicting changes made on different databases, which are replicated <span class="anchor" id="line-132"></span>to each other, as shown earlier. <span class="anchor" id="line-133"></span></li><li>Changes are written to the database using _bulk_docs and all_or_nothing, <span class="anchor" id="line-134"></span>which bypasses the 409 mechanism. <span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span></li></ol><p class="line874">The _bulk_docs API lets you submit multiple updates (and/or deletes) in a <span class="anchor" id="line-137"></span>single HTTP POST.  Normally, these are treated as independent updates; some <span class="anchor" id="line-138"></span>in the batch may fail because the _rev is stale (just like a 409 from a PUT) <span class="anchor" id="line-139"></span>whilst others are written successfully.  The response from _bulk_docs lists <span class="anchor" id="line-140"></span>the success/fail separately for each document in the batch. <span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span></p><p class="line874">However there is another mode of working, whereby you specify <span class="anchor" id="line-143"></span><tt class="backtick">{"all_or_nothing":true}</tt> as part of the request.  This is CouchDB's nearest <span class="anchor" id="line-144"></span>equivalent of a "transaction", but it's not the same as a database <span class="anchor" id="line-145"></span>transaction which can fail and roll back.  Rather, it means that <em>all</em> of <span class="anchor" id="line-146"></span>the changes in the request will be forcibly applied to the database, even if <span class="anchor" id="line-147"></span>that introduces conflicts.  The only guarantee you are given is that they <span class="anchor" id="line-148"></span>will either all be applied to the database, or none of them (e.g.  if the <span class="anchor" id="line-149"></span>power is pulled out before the update is finished writing to disk). <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span></p><p class="line874">So this gives you a way to introduce conflicts within a single database <span class="anchor" id="line-152"></span>instance.  If you choose to do this instead of PUT, it means you don't have <span class="anchor" id="line-153"></span>to write any code for the possibility of getting a 409 response, because you <span class="anchor" id="line-154"></span>will never get one.  Rather, you have to deal with conflicts appearing later <span class="anchor" id="line-155"></span>in the database, which is what you'd have to do in a multi-master <span class="anchor" id="line-156"></span>application anyway. <span class="anchor" id="line-157"></span><span class="anchor" id="line-158"></span></p><p class="line867"><span class="anchor" id="line-159"></span><span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><span class="anchor" id="line-168"></span></p><pre><span class="anchor" id="line-1-2"></span>POST /db/_bulk_docs
<span class="anchor" id="line-2-2"></span>{
<span class="anchor" id="line-3-2"></span>  "all_or_nothing": true,
<span class="anchor" id="line-4-2"></span>  "docs": [
<span class="anchor" id="line-5-2"></span>    {"_id":"x", "_rev":"1-xxx", ...},
<span class="anchor" id="line-6-2"></span>    {"_id":"y", "_rev":"1-yyy", ...},
<span class="anchor" id="line-7-2"></span>    ...
<span class="anchor" id="line-8-2"></span>  ]
<span class="anchor" id="line-9-2"></span>}</pre><span class="anchor" id="line-169"></span><span class="anchor" id="line-170"></span><p class="line867">
</p><h2 id="Revision_tree">Revision tree</h2>
<span class="anchor" id="line-171"></span><span class="anchor" id="line-172"></span><p class="line874">When you update a document in couchdb, it keeps a list of the previous revisions. <span class="anchor" id="line-173"></span>In the case where conflicting updates are introduced, this history branches into a <span class="anchor" id="line-174"></span>tree, where the current conflicting revisions for this document form the tips <span class="anchor" id="line-175"></span>(leaf nodes) of this tree. <span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span></p><p class="line867"><span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span></p><pre><span class="anchor" id="line-1-3"></span>      ,--&gt; r2a
<span class="anchor" id="line-2-3"></span>    r1 --&gt; r2b
<span class="anchor" id="line-3-3"></span>      `--&gt; r2c</pre><span class="anchor" id="line-182"></span><span class="anchor" id="line-183"></span><p class="line874">Each branch can then extend its history - for example if you read <span class="anchor" id="line-184"></span>revision r2b and then PUT with <tt class="backtick">?rev=r2b</tt> then you will make a new revision <span class="anchor" id="line-185"></span>along that particular branch. <span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span></p><p class="line867"><span class="anchor" id="line-188"></span><span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><span class="anchor" id="line-191"></span></p><pre><span class="anchor" id="line-1-4"></span>      ,--&gt; r2a -&gt; r3a -&gt; r4a
<span class="anchor" id="line-2-4"></span>    r1 --&gt; r2b -&gt; r3b
<span class="anchor" id="line-3-4"></span>      `--&gt; r2c -&gt; r3c</pre><span class="anchor" id="line-192"></span><span class="anchor" id="line-193"></span><p class="line874">Here, (r4a, r3b, r3c) are the set of conflicting revisions. The way you <span class="anchor" id="line-194"></span>resolve a conflict is to delete the leaf nodes along the other branches. <span class="anchor" id="line-195"></span>So when you combine (r4a+r3b+r3c) into a single merged document, you <span class="anchor" id="line-196"></span>would replace r4a and delete r3b and r3c. <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span></p><p class="line867"><span class="anchor" id="line-199"></span><span class="anchor" id="line-200"></span><span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span></p><pre><span class="anchor" id="line-1-5"></span>      ,--&gt; r2a -&gt; r3a -&gt; r4a -&gt; r5a
<span class="anchor" id="line-2-5"></span>    r1 --&gt; r2b -&gt; r3b -&gt; (r4b deleted)
<span class="anchor" id="line-3-5"></span>      `--&gt; r2c -&gt; r3c -&gt; (r4c deleted)</pre><span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line874">Note that r4b and r4c still exist as leaf nodes in the history tree, but as <span class="anchor" id="line-205"></span>deleted docs. You can retrieve them but they will be marked <tt class="backtick">"_deleted":true</tt>. <span class="anchor" id="line-206"></span><span class="anchor" id="line-207"></span></p><p class="line874">When you compact a database, the bodies of all the non-leaf documents are <span class="anchor" id="line-208"></span>discarded. However, the list of historical _revs is retained, for the benefit of <span class="anchor" id="line-209"></span>later conflict resolution in case you meet any old replicas of the database at <span class="anchor" id="line-210"></span>some time in future. There is "revision pruning" to stop this getting arbitrarily large. <span class="anchor" id="line-211"></span><span class="anchor" id="line-212"></span></p><p class="line867">
</p><h1 id="Working_with_conflicting_documents">Working with conflicting documents</h1>
<span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span><p class="line867">
</p><h2 id="Single_document_API">Single document API</h2>
<span class="anchor" id="line-215"></span><span class="anchor" id="line-216"></span><p class="line862">The basic <tt class="backtick">GET&nbsp;/db/bob</tt> operation will not show you any information about <span class="anchor" id="line-217"></span>conflicts. You see only the deterministically-chosen winner, and get no <span class="anchor" id="line-218"></span>indication as to whether other conflicting revisions exist or not. <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span></p><p class="line867"><span class="anchor" id="line-221"></span><span class="anchor" id="line-222"></span></p><pre><span class="anchor" id="line-1-6"></span>{"_id":"test","_rev":"2-b91bb807b4685080c6a651115ff558f5","hello":"bar"}</pre><span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><p class="line862">If you do <tt class="backtick">GET&nbsp;/db/bob?conflicts=true</tt>, and the document is in a conflict <span class="anchor" id="line-225"></span>state, then you will get the winner plus a _conflicts member containing an <span class="anchor" id="line-226"></span>array of the revs of the other, conflicting revision(s). You can then fetch <span class="anchor" id="line-227"></span>them individually using subsequent <tt class="backtick">GET&nbsp;/db/bob?rev=xxxx</tt> operations. <span class="anchor" id="line-228"></span><span class="anchor" id="line-229"></span></p><p class="line867"><span class="anchor" id="line-230"></span><span class="anchor" id="line-231"></span><span class="anchor" id="line-232"></span></p><pre><span class="anchor" id="line-1-7"></span>{"_id":"test","_rev":"2-b91bb807b4685080c6a651115ff558f5","hello":"bar",
<span class="anchor" id="line-2-6"></span>"_conflicts":["2-65db2a11b5172bf928e3bcf59f728970","2-5bc3c6319edf62d4c624277fdd0ae191"]}</pre><span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span><p class="line862">If you do <tt class="backtick">GET&nbsp;/db/bob?open_revs=all</tt> then you will get all the leaf nodes <span class="anchor" id="line-235"></span>of the revision tree. This <em>will</em> give you all the current conflicts, but will <span class="anchor" id="line-236"></span>also give you leaf nodes which have been deleted (i.e. parts of the conflict <span class="anchor" id="line-237"></span>history which have since been resolved). You can remove these by filtering <span class="anchor" id="line-238"></span>out documents with <tt class="backtick">"_deleted":true</tt>. <span class="anchor" id="line-239"></span><span class="anchor" id="line-240"></span></p><p class="line867"><span class="anchor" id="line-241"></span><span class="anchor" id="line-242"></span><span class="anchor" id="line-243"></span><span class="anchor" id="line-244"></span></p><pre><span class="anchor" id="line-1-8"></span>[{"ok":{"_id":"test","_rev":"2-5bc3c6319edf62d4c624277fdd0ae191","hello":"foo"}},
<span class="anchor" id="line-2-7"></span>{"ok":{"_id":"test","_rev":"2-65db2a11b5172bf928e3bcf59f728970","hello":"baz"}},
<span class="anchor" id="line-3-6"></span>{"ok":{"_id":"test","_rev":"2-b91bb807b4685080c6a651115ff558f5","hello":"bar"}}]</pre><span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><p class="line874">The "ok" tag is an artefact of open_revs, which also lets you list explicit <span class="anchor" id="line-247"></span>revisions as a JSON array, e.g. <tt class="backtick">open_revs=[rev1,rev2,rev3]</tt>. In this form, <span class="anchor" id="line-248"></span>it would be possible to request a revision which is now missing, because the <span class="anchor" id="line-249"></span>database has been compacted. <span class="anchor" id="line-250"></span><span class="anchor" id="line-251"></span></p><p class="line874">NOTE: the order of revisions returned by open_revs=all is NOT related to the <span class="anchor" id="line-252"></span>deterministic "winning" algorithm. In the above example, the winning revision is 2-b91b... <span class="anchor" id="line-253"></span>and happens to be returned last, but in other cases it can be returned in a <span class="anchor" id="line-254"></span>different position. <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span></p><p class="line874">Once you have retrieved all the conflicting revisions, your application can then <span class="anchor" id="line-257"></span>choose to display them all to the user. Or it could attempt to merge them, write <span class="anchor" id="line-258"></span>back the merged version, and delete the conflicting versions - that is, to resolve <span class="anchor" id="line-259"></span>the conflict permanently. <span class="anchor" id="line-260"></span><span class="anchor" id="line-261"></span></p><p class="line874">As described above, you need to update one revision and delete all the conflicting <span class="anchor" id="line-262"></span>revisions explicitly. This can be done using a single POST to _bulk_docs, setting <span class="anchor" id="line-263"></span><tt class="backtick">"_deleted":true</tt> on those revisions you wish to delete. <span class="anchor" id="line-264"></span><span class="anchor" id="line-265"></span></p><p class="line867">
</p><h2 id="Multiple_document_API">Multiple document API</h2>
<span class="anchor" id="line-266"></span><span class="anchor" id="line-267"></span><p class="line862">You can fetch multiple documents at once using <tt class="backtick">include_docs=true</tt> on a view. However, <span class="anchor" id="line-268"></span>a <tt class="backtick">conflicts=true</tt> request is ignored; the "doc" part of the value never includes a <span class="anchor" id="line-269"></span><tt class="backtick">_conflicts</tt> member. Hence you would need to do another query to determine for each <span class="anchor" id="line-270"></span>document whether it is in a conflicting state. <span class="anchor" id="line-271"></span><span class="anchor" id="line-272"></span></p><p class="line867"><span class="anchor" id="line-273"></span><span class="anchor" id="line-274"></span><span class="anchor" id="line-275"></span><span class="anchor" id="line-276"></span><span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span><span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span><span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span></p><pre><span class="anchor" id="line-1-9"></span>$ curl 'http://127.0.0.1:5984/conflict_test/_all_docs?include_docs=true&amp;conflicts=true'
<span class="anchor" id="line-2-8"></span>{"total_rows":1,"offset":0,"rows":[
<span class="anchor" id="line-3-7"></span>{"id":"test","key":"test","value":{"rev":"2-b91bb807b4685080c6a651115ff558f5"},
<span class="anchor" id="line-4-3"></span>"doc":{"_id":"test","_rev":"2-b91bb807b4685080c6a651115ff558f5","hello":"bar"}}
<span class="anchor" id="line-5-3"></span>]}
<span class="anchor" id="line-6-3"></span>$ curl 'http://127.0.0.1:5984/conflict_test/test?conflicts=true'
<span class="anchor" id="line-7-3"></span>{"_id":"test","_rev":"2-b91bb807b4685080c6a651115ff558f5","hello":"bar",
<span class="anchor" id="line-8-3"></span>"_conflicts":["2-65db2a11b5172bf928e3bcf59f728970","2-5bc3c6319edf62d4c624277fdd0ae191"]}</pre><span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><p class="line867">
</p><h2 id="View_map_functions">View map functions</h2>
<span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><p class="line874">Views only get the winning revision of a document. However they do also <span class="anchor" id="line-287"></span>get a _conflicts member if there are any conflicting revisions.  This means <span class="anchor" id="line-288"></span>you can write a view whose job is specifically to locate documents with <span class="anchor" id="line-289"></span>conflicts. Here is a simple map function which achieves this: <span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span></p><p class="line867"><span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><span class="anchor" id="line-297"></span></p><pre><span class="anchor" id="line-1-10"></span>function(doc) {
<span class="anchor" id="line-2-9"></span>  if (doc._conflicts) {
<span class="anchor" id="line-3-8"></span>    emit(null, [doc._rev].concat(doc._conflicts));
<span class="anchor" id="line-4-4"></span>  }
<span class="anchor" id="line-5-4"></span>}</pre><span class="anchor" id="line-298"></span><span class="anchor" id="line-299"></span><p class="line874">which gives the following output: <span class="anchor" id="line-300"></span><span class="anchor" id="line-301"></span></p><p class="line867"><span class="anchor" id="line-302"></span><span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><span class="anchor" id="line-305"></span><span class="anchor" id="line-306"></span></p><pre><span class="anchor" id="line-1-11"></span>{"total_rows":1,"offset":0,"rows":[
<span class="anchor" id="line-2-10"></span>{"id":"test","key":null,"value":["2-b91bb807b4685080c6a651115ff558f5",
<span class="anchor" id="line-3-9"></span>"2-65db2a11b5172bf928e3bcf59f728970","2-5bc3c6319edf62d4c624277fdd0ae191"]}
<span class="anchor" id="line-4-5"></span>]}</pre><span class="anchor" id="line-307"></span><span class="anchor" id="line-308"></span><p class="line874">If you do this, you can have a separate "sweep" process which periodically <span class="anchor" id="line-309"></span>scans your database, looks for documents which have conflicts, fetches <span class="anchor" id="line-310"></span>the conflicting revisions, and resolves them. <span class="anchor" id="line-311"></span><span class="anchor" id="line-312"></span></p><p class="line874">Whilst this keeps the main application simple, the problem with this <span class="anchor" id="line-313"></span>approach is that there will be a window between a conflict being introduced <span class="anchor" id="line-314"></span>and it being resolved. From a user's viewpoint, this may appear that <span class="anchor" id="line-315"></span>the document they just saved successfully may suddenly lose their changes, <span class="anchor" id="line-316"></span>only to be resurrected some time later. This may or may not be acceptable. <span class="anchor" id="line-317"></span><span class="anchor" id="line-318"></span></p><p class="line874">Also, it's easy to forget to start the sweeper, or not to implement it <span class="anchor" id="line-319"></span>properly, and this will introduce odd behaviour which will be hard to track <span class="anchor" id="line-320"></span>down. <span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span></p><p class="line874">Couchdb's "winning" revision algorithm may mean that information drops out <span class="anchor" id="line-323"></span>of a view until a conflict has been resolved. Consider Bob's business card <span class="anchor" id="line-324"></span>again; suppose Alice has a view which emits mobile numbers, so that her <span class="anchor" id="line-325"></span>telephony application can display the caller's name based on caller ID. If there <span class="anchor" id="line-326"></span>are conflicting documents with Bob's old and new mobile numbers, and they <span class="anchor" id="line-327"></span>happen to be resolved in favour of Bob's old number, then the view won't <span class="anchor" id="line-328"></span>be able to recognise his new one. In this particular case, the application <span class="anchor" id="line-329"></span>might have preferred to put information from <em>both</em> the conflicting <span class="anchor" id="line-330"></span>documents into the view, but this currently isn't possible. <span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span></p><p class="line867">
</p><h2 id="Suggested_code_to_fetch_a_document_with_conflict_resolution">Suggested code to fetch a document with conflict resolution</h2>
<span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><p class="line874">Pseudocode: <span class="anchor" id="line-335"></span><span class="anchor" id="line-336"></span><span class="anchor" id="line-337"></span><span class="anchor" id="line-338"></span><span class="anchor" id="line-339"></span><span class="anchor" id="line-340"></span><span class="anchor" id="line-341"></span><span class="anchor" id="line-342"></span><span class="anchor" id="line-343"></span><span class="anchor" id="line-344"></span><span class="anchor" id="line-345"></span></p><pre><span class="anchor" id="line-1-12"></span>  1. GET docid?conflicts=true
<span class="anchor" id="line-2-11"></span>  2. For each member in the _conflicts array:
<span class="anchor" id="line-3-10"></span>       GET docid?rev=xxx
<span class="anchor" id="line-4-6"></span>     If any errors occur at this stage, restart from step 1.
<span class="anchor" id="line-5-5"></span>     (There could be a race where someone else has already resolved this
<span class="anchor" id="line-6-4"></span>     conflict and deleted that rev)
<span class="anchor" id="line-7-4"></span>  3. Perform application-specific merging
<span class="anchor" id="line-8-4"></span>  4. Write _bulk_docs with an update to the first rev and deletes of
<span class="anchor" id="line-9-3"></span>     the other revs.</pre><span class="anchor" id="line-346"></span><span class="anchor" id="line-347"></span><p class="line874">This could either be done on every read (in which case you could replace all <span class="anchor" id="line-348"></span>calls to GET in your application with calls to a library which does the <span class="anchor" id="line-349"></span>above), or as part of your sweeper code. <span class="anchor" id="line-350"></span><span class="anchor" id="line-351"></span></p><p class="line862">And here is an example of this in Ruby using the low-level <a class="nonexistent" href="http://wiki.apache.org/couchdb/RestClient">RestClient</a>. <span class="anchor" id="line-352"></span><span class="anchor" id="line-353"></span></p><p class="line867"><span class="anchor" id="line-354"></span><span class="anchor" id="line-355"></span><span class="anchor" id="line-356"></span><span class="anchor" id="line-357"></span><span class="anchor" id="line-358"></span><span class="anchor" id="line-359"></span><span class="anchor" id="line-360"></span><span class="anchor" id="line-361"></span><span class="anchor" id="line-362"></span><span class="anchor" id="line-363"></span><span class="anchor" id="line-364"></span><span class="anchor" id="line-365"></span><span class="anchor" id="line-366"></span><span class="anchor" id="line-367"></span><span class="anchor" id="line-368"></span><span class="anchor" id="line-369"></span><span class="anchor" id="line-370"></span><span class="anchor" id="line-371"></span><span class="anchor" id="line-372"></span><span class="anchor" id="line-373"></span><span class="anchor" id="line-374"></span><span class="anchor" id="line-375"></span><span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span><span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><span class="anchor" id="line-382"></span><span class="anchor" id="line-383"></span><span class="anchor" id="line-384"></span><span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><span class="anchor" id="line-389"></span><span class="anchor" id="line-390"></span><span class="anchor" id="line-391"></span><span class="anchor" id="line-392"></span><span class="anchor" id="line-393"></span><span class="anchor" id="line-394"></span><span class="anchor" id="line-395"></span><span class="anchor" id="line-396"></span><span class="anchor" id="line-397"></span><span class="anchor" id="line-398"></span><span class="anchor" id="line-399"></span><span class="anchor" id="line-400"></span><span class="anchor" id="line-401"></span><span class="anchor" id="line-402"></span><span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span><span class="anchor" id="line-405"></span><span class="anchor" id="line-406"></span><span class="anchor" id="line-407"></span><span class="anchor" id="line-408"></span><span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span><span class="anchor" id="line-411"></span><span class="anchor" id="line-412"></span><span class="anchor" id="line-413"></span><span class="anchor" id="line-414"></span><span class="anchor" id="line-415"></span><span class="anchor" id="line-416"></span><span class="anchor" id="line-417"></span><span class="anchor" id="line-418"></span><span class="anchor" id="line-419"></span><span class="anchor" id="line-420"></span><span class="anchor" id="line-421"></span></p><pre><span class="anchor" id="line-1-13"></span>require 'rubygems'
<span class="anchor" id="line-2-12"></span>require 'restclient'
<span class="anchor" id="line-3-11"></span>require 'json'
<span class="anchor" id="line-4-7"></span>DB="http://127.0.0.1:5984/conflict_test"
<span class="anchor" id="line-5-6"></span>
<span class="anchor" id="line-6-5"></span># Write multiple documents as all_or_nothing, can introduce conflicts
<span class="anchor" id="line-7-5"></span>def writem(docs)
<span class="anchor" id="line-8-5"></span>  JSON.parse(RestClient.post("#{DB}/_bulk_docs", {
<span class="anchor" id="line-9-4"></span>    "all_or_nothing" =&gt; true,
<span class="anchor" id="line-10-2"></span>    "docs" =&gt; docs,
<span class="anchor" id="line-11-2"></span>  }.to_json))
<span class="anchor" id="line-12-1"></span>end
<span class="anchor" id="line-13-1"></span>
<span class="anchor" id="line-14-1"></span># Write one document, return the rev
<span class="anchor" id="line-15-1"></span>def write1(doc, id=nil, rev=nil)
<span class="anchor" id="line-16-1"></span>  doc['_id'] = id if id
<span class="anchor" id="line-17-1"></span>  doc['_rev'] = rev if rev
<span class="anchor" id="line-18-1"></span>  writem([doc]).first['rev']
<span class="anchor" id="line-19-1"></span>end
<span class="anchor" id="line-20-1"></span>
<span class="anchor" id="line-21-1"></span># Read a document, return *all* revs
<span class="anchor" id="line-22-1"></span>def read1(id)
<span class="anchor" id="line-23-1"></span>  retries = 0
<span class="anchor" id="line-24-1"></span>  loop do
<span class="anchor" id="line-25-1"></span>    # FIXME: escape id
<span class="anchor" id="line-26-1"></span>    res = [JSON.parse(RestClient.get("#{DB}/#{id}?conflicts=true"))]
<span class="anchor" id="line-27-1"></span>    if revs = res.first.delete('_conflicts')
<span class="anchor" id="line-28"></span>      begin
<span class="anchor" id="line-29"></span>        revs.each do |rev|
<span class="anchor" id="line-30"></span>          res &lt;&lt; JSON.parse(RestClient.get("#{DB}/#{id}?rev=#{rev}"))
<span class="anchor" id="line-31"></span>        end
<span class="anchor" id="line-32"></span>      rescue
<span class="anchor" id="line-33"></span>        retries += 1
<span class="anchor" id="line-34"></span>        raise if retries &gt;= 5
<span class="anchor" id="line-35"></span>        next
<span class="anchor" id="line-36"></span>      end
<span class="anchor" id="line-37"></span>    end
<span class="anchor" id="line-38"></span>    return res
<span class="anchor" id="line-39"></span>  end
<span class="anchor" id="line-40"></span>end
<span class="anchor" id="line-41"></span>
<span class="anchor" id="line-42"></span># Create DB
<span class="anchor" id="line-43"></span>RestClient.delete DB rescue nil
<span class="anchor" id="line-44"></span>RestClient.put DB, {}.to_json
<span class="anchor" id="line-45"></span>
<span class="anchor" id="line-46"></span># Write a document
<span class="anchor" id="line-47"></span>rev1 = write1({"hello"=&gt;"xxx"},"test")
<span class="anchor" id="line-48"></span>p read1("test")
<span class="anchor" id="line-49"></span>
<span class="anchor" id="line-50"></span># Make three conflicting versions
<span class="anchor" id="line-51"></span>write1({"hello"=&gt;"foo"},"test",rev1)
<span class="anchor" id="line-52"></span>write1({"hello"=&gt;"bar"},"test",rev1)
<span class="anchor" id="line-53"></span>write1({"hello"=&gt;"baz"},"test",rev1)
<span class="anchor" id="line-54"></span>
<span class="anchor" id="line-55"></span>res = read1("test")
<span class="anchor" id="line-56"></span>p res
<span class="anchor" id="line-57"></span>
<span class="anchor" id="line-58"></span># Now let's replace these three with one
<span class="anchor" id="line-59"></span>res.first['hello'] = "foo+bar+baz"
<span class="anchor" id="line-60"></span>res.each_with_index do |r,i|
<span class="anchor" id="line-61"></span>  unless i == 0
<span class="anchor" id="line-62"></span>    r.replace({'_id'=&gt;r['_id'], '_rev'=&gt;r['_rev'], '_deleted'=&gt;true})
<span class="anchor" id="line-63"></span>  end
<span class="anchor" id="line-64"></span>end
<span class="anchor" id="line-65"></span>writem(res)
<span class="anchor" id="line-66"></span>
<span class="anchor" id="line-67"></span>p read1("test")</pre><span class="anchor" id="line-422"></span><span class="anchor" id="line-423"></span><p class="line874">An application written this way never has to deal with a PUT 409, and is <span class="anchor" id="line-424"></span>automatically multi-master capable. <span class="anchor" id="line-425"></span><span class="anchor" id="line-426"></span></p><p class="line874">You can see that it's straightforward enough when you know what you're <span class="anchor" id="line-427"></span>doing.  It's just that CouchDB doesn't currently provide a convenient HTTP <span class="anchor" id="line-428"></span>API for "fetch all conflicting revisions", nor "PUT to supercede these N <span class="anchor" id="line-429"></span>revisions", so you need to wrap these yourself.  I also don't know of any <span class="anchor" id="line-430"></span>client-side libraries which provide support for this. <span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span></p><p class="line867">
</p><h2 id="Merging_and_revision_history">Merging and revision history</h2>
<span class="anchor" id="line-433"></span><span class="anchor" id="line-434"></span><p class="line874">Actually performing the merge is an application-specific function. It <span class="anchor" id="line-435"></span>depends on the structure of your data. Sometimes it will be easy: e.g. if a <span class="anchor" id="line-436"></span>document contains a list which is only ever appended to, then you can <span class="anchor" id="line-437"></span>perform a union of the two list versions. <span class="anchor" id="line-438"></span><span class="anchor" id="line-439"></span></p><p class="line874">Some merge strategies look at the changes made to an object, compared to its <span class="anchor" id="line-440"></span>previous version.  This is how git's merge function works.  For example, to <span class="anchor" id="line-441"></span>merge Bob's business card versions v2a and v2b, you could look at the <span class="anchor" id="line-442"></span>differences between v1 and v2b, and then apply these changes to v2a as well. <span class="anchor" id="line-443"></span><span class="anchor" id="line-444"></span></p><p class="line874">With CouchDB, you can sometimes get hold of old revisions of a document.  <span class="anchor" id="line-445"></span>For example, if you fetch <tt class="backtick">/db/bob?rev=v2b&amp;revs_info=true</tt> you'll get a list <span class="anchor" id="line-446"></span>of the previous revision ids which ended up with revision v2b.  Doing the <span class="anchor" id="line-447"></span>same for v2a you can find their common ancestor revision.  However if the <span class="anchor" id="line-448"></span>database has been compacted, the content of that document revision will have <span class="anchor" id="line-449"></span>been lost.  revs_info will still show that v1 was an ancestor, but report it <span class="anchor" id="line-450"></span>as "missing". <span class="anchor" id="line-451"></span><span class="anchor" id="line-452"></span></p><p class="line867"><span class="anchor" id="line-453"></span><span class="anchor" id="line-454"></span><span class="anchor" id="line-455"></span><span class="anchor" id="line-456"></span><span class="anchor" id="line-457"></span><span class="anchor" id="line-458"></span></p><pre><span class="anchor" id="line-1-14"></span>BEFORE COMPACTION           AFTER COMPACTION
<span class="anchor" id="line-2-13"></span>
<span class="anchor" id="line-3-12"></span>     ,-&gt; v2a                     v2a
<span class="anchor" id="line-4-8"></span>   v1
<span class="anchor" id="line-5-7"></span>     `-&gt; v2b                     v2b</pre><span class="anchor" id="line-459"></span><span class="anchor" id="line-460"></span><p class="line874">So if you want to work with diffs, the recommended way is to store those <span class="anchor" id="line-461"></span>diffs within the new revision itself.  That is: when you replace v1 with <span class="anchor" id="line-462"></span>v2a, include an extra field or attachment in v2a which says which fields <span class="anchor" id="line-463"></span>were changed from v1 to v2a.  This unfortunately does mean additional <span class="anchor" id="line-464"></span>book-keeping for your application. <span class="anchor" id="line-465"></span><span class="anchor" id="line-466"></span></p><p class="line867">
</p><h1 id="Comparison_with_other_replicating_data_stores">Comparison with other replicating data stores</h1>
<span class="anchor" id="line-467"></span><span class="anchor" id="line-468"></span><p class="line874">The same issues arise with other replicating systems, so it can be <span class="anchor" id="line-469"></span>instructive to look at these and see how they compare with CouchDB. Please <span class="anchor" id="line-470"></span>feel free to add other examples. <span class="anchor" id="line-471"></span><span class="anchor" id="line-472"></span></p><p class="line867">
</p><h2 id="Unison">Unison</h2>
<span class="anchor" id="line-473"></span><span class="anchor" id="line-474"></span><p class="line867"><a class="http" href="http://www.cis.upenn.edu/~bcpierce/unison/">Unison</a> is a bi-directional file <span class="anchor" id="line-475"></span>synchronisation tool. In this case, the business card would be a file, <span class="anchor" id="line-476"></span>say bob.vcf. <span class="anchor" id="line-477"></span><span class="anchor" id="line-478"></span></p><p class="line874">When you run unison, changes propagate both ways. If a file has changed on <span class="anchor" id="line-479"></span>one side but not the other, the new replaces the old. (Unison maintains a <span class="anchor" id="line-480"></span>local state file so that it knows whether a file has changed since the last <span class="anchor" id="line-481"></span>successful replication). <span class="anchor" id="line-482"></span><span class="anchor" id="line-483"></span></p><p class="line874">In our example it has changed on both sides. Only one file called "bob.vcf" <span class="anchor" id="line-484"></span>can exist within the filesystem.  Unison solves the problem by simply <span class="anchor" id="line-485"></span>ducking out: the user can choose to replace the remote version with the <span class="anchor" id="line-486"></span>local version, or vice versa (both of which would lose data), but the <span class="anchor" id="line-487"></span>default action is to leave both sides unchanged. <span class="anchor" id="line-488"></span><span class="anchor" id="line-489"></span></p><p class="line874">From Alice's point of view, at least this is a simple solution. Whenever <span class="anchor" id="line-490"></span>she's on the desktop she'll see the version she last edited on the desktop, <span class="anchor" id="line-491"></span>and whenever she's on the laptop she'll see the version she last edited <span class="anchor" id="line-492"></span>there. <span class="anchor" id="line-493"></span><span class="anchor" id="line-494"></span></p><p class="line874">But because no replication has actually taken place, the data is not <span class="anchor" id="line-495"></span>protected. If her laptop hard drive dies, she'll lose all her changes made <span class="anchor" id="line-496"></span>on the laptop; ditto if her desktop hard drive dies. <span class="anchor" id="line-497"></span><span class="anchor" id="line-498"></span></p><p class="line874">It's up to her to copy across one of the versions manually (under a <span class="anchor" id="line-499"></span>different filename), merge the two, and then finally push the merged version <span class="anchor" id="line-500"></span>to the other side. <span class="anchor" id="line-501"></span><span class="anchor" id="line-502"></span></p><p class="line874">Note also that the original file (version v1) has been lost by this point. <span class="anchor" id="line-503"></span>So it's not going to be known from inspection alone which of v2a and v2b has <span class="anchor" id="line-504"></span>the most up-to-date E-mail address for Bob, and which has the most <span class="anchor" id="line-505"></span>up-to-date mobile number.  Alice has to remember which she entered last. <span class="anchor" id="line-506"></span><span class="anchor" id="line-507"></span></p><p class="line867">
</p><h2 id="Git">Git</h2>
<span class="anchor" id="line-508"></span><span class="anchor" id="line-509"></span><p class="line867"><a class="http" href="http://git-scm.com/">Git</a> is a well-known distributed source control system. <span class="anchor" id="line-510"></span>Like unison, git deals with files. However, git considers the state of a <span class="anchor" id="line-511"></span>whole set of files as a single object, the "tree". Whenever you save an <span class="anchor" id="line-512"></span>update, you create a "commit" which points to both the updated tree and the <span class="anchor" id="line-513"></span>previous commit(s), which in turn point to the previous tree(s). You <span class="anchor" id="line-514"></span>therefore have a full history of all the states of the files. This forms a <span class="anchor" id="line-515"></span>branch, and a pointer is kept to the tip of the branch, from which you can <span class="anchor" id="line-516"></span>work backwards to any previous state. The "pointer" is actually an SHA1 hash <span class="anchor" id="line-517"></span>of the tip commit. <span class="anchor" id="line-518"></span><span class="anchor" id="line-519"></span></p><p class="line874">If you are replicating with one or more peers, a separate branch is made for <span class="anchor" id="line-520"></span>each of the peers. For example, you might have <span class="anchor" id="line-521"></span><span class="anchor" id="line-522"></span><span class="anchor" id="line-523"></span><span class="anchor" id="line-524"></span><span class="anchor" id="line-525"></span></p><pre><span class="anchor" id="line-1-15"></span>    master               -- my local branch
<span class="anchor" id="line-2-14"></span>    remotes/foo/master   -- branch on peer 'foo'
<span class="anchor" id="line-3-13"></span>    remotes/bar/master   -- branch on peer 'bar'</pre><span class="anchor" id="line-526"></span><span class="anchor" id="line-527"></span><p class="line874">In the normal way of working, replication is a "pull", importing changes <span class="anchor" id="line-528"></span>from a remote peer into the local repository.  A "pull" does two things: <span class="anchor" id="line-529"></span>first "fetch" the state of the peer into the remote tracking branch for that <span class="anchor" id="line-530"></span>peer; and then attempt to "merge" those changes into the local branch. <span class="anchor" id="line-531"></span><span class="anchor" id="line-532"></span></p><p class="line874">Now let's consider the business card. Alice has created a git repo <span class="anchor" id="line-533"></span>containing bob.vcf, and cloned it across to the other machine. The <span class="anchor" id="line-534"></span>branches look like this, where AAAAAAAA is the SHA1 of the commit. <span class="anchor" id="line-535"></span><span class="anchor" id="line-536"></span></p><p class="line867"><span class="anchor" id="line-537"></span><span class="anchor" id="line-538"></span><span class="anchor" id="line-539"></span><span class="anchor" id="line-540"></span></p><pre><span class="anchor" id="line-1-16"></span>  ---------- desktop ----------           ---------- laptop ----------
<span class="anchor" id="line-2-15"></span>  master: AAAAAAAA                        master: AAAAAAAA
<span class="anchor" id="line-3-14"></span>  remotes/laptop/master: AAAAAAAA         remotes/desktop/master: AAAAAAAA</pre><span class="anchor" id="line-541"></span><span class="anchor" id="line-542"></span><p class="line874">Now she makes a change on the desktop, and commits it into the desktop repo; <span class="anchor" id="line-543"></span>then she makes a different change on the laptop, and commits it into the <span class="anchor" id="line-544"></span>laptop repo. <span class="anchor" id="line-545"></span><span class="anchor" id="line-546"></span></p><p class="line867"><span class="anchor" id="line-547"></span><span class="anchor" id="line-548"></span><span class="anchor" id="line-549"></span><span class="anchor" id="line-550"></span></p><pre><span class="anchor" id="line-1-17"></span>  ---------- desktop ----------           ---------- laptop ----------
<span class="anchor" id="line-2-16"></span>  master: BBBBBBBB                        master: CCCCCCCC
<span class="anchor" id="line-3-15"></span>  remotes/laptop/master: AAAAAAAA         remotes/desktop/master: AAAAAAAA</pre><span class="anchor" id="line-551"></span><span class="anchor" id="line-552"></span><p class="line874">Now on the desktop she does "git pull laptop". Firstly, the remote objects <span class="anchor" id="line-553"></span>are copied across into the local repo and the remote tracking branch is <span class="anchor" id="line-554"></span>updated: <span class="anchor" id="line-555"></span><span class="anchor" id="line-556"></span></p><p class="line867"><span class="anchor" id="line-557"></span><span class="anchor" id="line-558"></span><span class="anchor" id="line-559"></span><span class="anchor" id="line-560"></span><span class="anchor" id="line-561"></span><span class="anchor" id="line-562"></span><span class="anchor" id="line-563"></span><span class="anchor" id="line-564"></span></p><pre><span class="anchor" id="line-1-18"></span>  ---------- desktop ----------           ---------- laptop ----------
<span class="anchor" id="line-2-17"></span>  master: BBBBBBBB                        master: CCCCCCCC
<span class="anchor" id="line-3-16"></span>  remotes/laptop/master: CCCCCCCC         remotes/desktop/master: AAAAAAAA
<span class="anchor" id="line-4-9"></span>
<span class="anchor" id="line-5-8"></span>  (note: repo still contains AAAAAAAA
<span class="anchor" id="line-6-6"></span>  because commits BBBBBBBB and
<span class="anchor" id="line-7-6"></span>  CCCCCCCC point to it)</pre><span class="anchor" id="line-565"></span><span class="anchor" id="line-566"></span><p class="line874">Then git will attempt to merge the changes in. It can do this because it <span class="anchor" id="line-567"></span>knows the parent commit to CCCCCCCC is AAAAAAAA, so it takes a diff between <span class="anchor" id="line-568"></span>AAAAAAAA and CCCCCCCC and tries to apply it to BBBBBBBB. If this is <span class="anchor" id="line-569"></span>successful, then you'll get a new version with a merge commit. <span class="anchor" id="line-570"></span><span class="anchor" id="line-571"></span></p><p class="line867"><span class="anchor" id="line-572"></span><span class="anchor" id="line-573"></span><span class="anchor" id="line-574"></span><span class="anchor" id="line-575"></span></p><pre><span class="anchor" id="line-1-19"></span>  ---------- desktop ----------           ---------- laptop ----------
<span class="anchor" id="line-2-18"></span>  master: DDDDDDDD                        master: CCCCCCCC
<span class="anchor" id="line-3-17"></span>  remotes/laptop/master: CCCCCCCC         remotes/desktop/master: AAAAAAAA</pre><span class="anchor" id="line-576"></span><span class="anchor" id="line-577"></span><p class="line874">Then Alice has to logon to the laptop and run "git pull desktop". A similar <span class="anchor" id="line-578"></span>process occurs. The remote tracking branch is updated: <span class="anchor" id="line-579"></span><span class="anchor" id="line-580"></span></p><p class="line867"><span class="anchor" id="line-581"></span><span class="anchor" id="line-582"></span><span class="anchor" id="line-583"></span><span class="anchor" id="line-584"></span></p><pre><span class="anchor" id="line-1-20"></span>  ---------- desktop ----------           ---------- laptop ----------
<span class="anchor" id="line-2-19"></span>  master: DDDDDDDD                        master: CCCCCCCC
<span class="anchor" id="line-3-18"></span>  remotes/laptop/master: CCCCCCCC         remotes/desktop/master: DDDDDDDD</pre><span class="anchor" id="line-585"></span><span class="anchor" id="line-586"></span><p class="line874">then a merge takes place. This is a special-case: CCCCCCCC one of the parent <span class="anchor" id="line-587"></span>commits of DDDDDDDD, so the laptop can "fast forward" update from CCCCCCCC <span class="anchor" id="line-588"></span>to DDDDDDDD directly without having to do any complex merging. This leaves <span class="anchor" id="line-589"></span>the final state as: <span class="anchor" id="line-590"></span><span class="anchor" id="line-591"></span></p><p class="line867"><span class="anchor" id="line-592"></span><span class="anchor" id="line-593"></span><span class="anchor" id="line-594"></span><span class="anchor" id="line-595"></span></p><pre><span class="anchor" id="line-1-21"></span>  ---------- desktop ----------           ---------- laptop ----------
<span class="anchor" id="line-2-20"></span>  master: DDDDDDDD                        master: DDDDDDDD
<span class="anchor" id="line-3-19"></span>  remotes/laptop/master: CCCCCCCC         remotes/desktop/master: DDDDDDDD</pre><span class="anchor" id="line-596"></span><span class="anchor" id="line-597"></span><p class="line874">Now this is all and good, but you may wonder how this is relevant when <span class="anchor" id="line-598"></span>thinking about couchdb. <span class="anchor" id="line-599"></span><span class="anchor" id="line-600"></span></p><p class="line874">Firstly, note what happens in the case when the merge algorithm fails. The <span class="anchor" id="line-601"></span>changes <em>are</em> still propagated from the remote repo into the local one, <span class="anchor" id="line-602"></span>and are available in the remote tracking branch; so unlike unison, you know <span class="anchor" id="line-603"></span>the data is protected. It's just that the local working copy may fail to <span class="anchor" id="line-604"></span>update, or may diverge from the remote version. It's up to you to create and <span class="anchor" id="line-605"></span>commit the combined version yourself, but you are guaranteed to have all the <span class="anchor" id="line-606"></span>history you might need to do this. <span class="anchor" id="line-607"></span><span class="anchor" id="line-608"></span></p><p class="line874">Note that whilst it's possible to build new merge algorithms into Git, the <span class="anchor" id="line-609"></span>standard ones are focussed on line-based changes to source code.  They don't <span class="anchor" id="line-610"></span>work well for XML or JSON if it's presented without any line breaks. <span class="anchor" id="line-611"></span><span class="anchor" id="line-612"></span></p><p class="line874">The other interesting consideration is multiple peers. In this case you have <span class="anchor" id="line-613"></span>multiple remote tracking branches, some of which may match your local <span class="anchor" id="line-614"></span>branch, some of which may be behind you, and some of which may be ahead of <span class="anchor" id="line-615"></span>you (i.e. contain changes that you haven't yet merged). <span class="anchor" id="line-616"></span><span class="anchor" id="line-617"></span></p><p class="line867"><span class="anchor" id="line-618"></span><span class="anchor" id="line-619"></span><span class="anchor" id="line-620"></span><span class="anchor" id="line-621"></span><span class="anchor" id="line-622"></span></p><pre><span class="anchor" id="line-1-22"></span>  master: AAAAAAAA
<span class="anchor" id="line-2-21"></span>  remotes/foo/master: BBBBBBBB
<span class="anchor" id="line-3-20"></span>  remotes/bar/master: CCCCCCCC
<span class="anchor" id="line-4-10"></span>  remotes/baz/master: AAAAAAAA</pre><span class="anchor" id="line-623"></span><span class="anchor" id="line-624"></span><p class="line874">Note that each peer is explicitly tracked, and therefore has to be <span class="anchor" id="line-625"></span>explicitly created.  If a peer becomes stale or is no longer needed, it's up <span class="anchor" id="line-626"></span>to you to remove it from your configuration and delete the remote tracking <span class="anchor" id="line-627"></span>branch.  This is different to couchdb, which doesn't keep any peer state in <span class="anchor" id="line-628"></span>the database. <span class="anchor" id="line-629"></span><span class="anchor" id="line-630"></span></p><p class="line874">Another difference with git is that it maintains all history back to time zero - <span class="anchor" id="line-631"></span>git compaction keeps diffs between all those versions in order to reduce size, <span class="anchor" id="line-632"></span>but couchdb discards them. If you are constantly updating a document, the size <span class="anchor" id="line-633"></span>of a git repo would grow forever. It is possible (with some effort) to use <span class="anchor" id="line-634"></span>"history rewriting" to make git forget commits earlier than a particular one. <span class="anchor" id="line-635"></span><span class="anchor" id="line-636"></span></p><p class="line867">
</p><h2 id="Amazon_Dynamo">Amazon Dynamo</h2>
<span class="anchor" id="line-637"></span><span class="anchor" id="line-638"></span><p class="line867"><a class="http" href="http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html">Dynamo</a> <span class="anchor" id="line-639"></span>is designed as an "always writeable" key-value store, so it has no equivalent to the <span class="anchor" id="line-640"></span>409 conflict avoidance. It encourages users to perform conflict resolution <span class="anchor" id="line-641"></span>on read: a read operation provides all the conflicting versions plus a <span class="anchor" id="line-642"></span>"context". The write operation supplies the same context and this <span class="anchor" id="line-643"></span>supercedes all the previous revisions in one go. <span class="anchor" id="line-644"></span><span class="anchor" id="bottom"></span></p></div><p id="pageinfo" class="info" lang="en" dir="ltr">Replication_and_conflicts  (last edited 2011-11-23 15:03:32 by <span title="JanLehnardt @ 62.220.4.189[62.220.4.189]"><a class="nonexistent" href="http://wiki.apache.org/couchdb/JanLehnardt" title="JanLehnardt @ 62.220.4.189[62.220.4.189]">JanLehnardt</a></span>)</p>

<div id="pagebottom"></div>
</div>


<div id="footer">
<ul class="editbar"><li><span class="disabled">Immutable Page</span></li><li class="toggleCommentsButton" style="display:none;"><a href="http://wiki.apache.org/couchdb/Replication_and_conflicts#" class="nbcomment" onclick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="http://wiki.apache.org/couchdb/Replication_and_conflicts?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="./Replication_and_conflicts - Couchdb Wiki_files/Replication_and_conflicts - Couchdb Wiki.html">
<div>
    
    <select name="action" onchange="if ((this.selectedIndex != 0) &amp;&amp;
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="show">More Actions:</option><option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="RenderAsDocbook">Render as Docbook</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="RenamePage" disabled="" class="disabled">Rename Page</option>
<option value="CopyPage">Copy Page</option>
<option value="DeletePage" disabled="" class="disabled">Delete Page</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="MyPages">My Pages</option>
<option value="show" disabled="" class="disabled">Subscribe User</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="show" disabled="" class="disabled">Remove Spam</option>
<option value="show" disabled="" class="disabled">Revert to this revision</option>
<option value="PackagePages">Package Pages</option>
<option value="SyncPages">Sync Pages</option>
<option value="show" disabled="" class="disabled">------------------------</option>
<option value="Load">Load</option>
<option value="Save">Save</option>
<option value="SlideShow">SlideShow</option>
    </select>
    
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>



<script id="hiddenlpsubmitdiv" style="display: none;"></script><script>try{for(var lastpass_iter=0; lastpass_iter < document.forms.length; lastpass_iter++){ var lastpass_f = document.forms[lastpass_iter]; if(typeof(lastpass_f.lpsubmitorig2)=="undefined"){ lastpass_f.lpsubmitorig2 = lastpass_f.submit; if (typeof(lastpass_f.lpsubmitorig2)=='object'){ continue;}lastpass_f.submit = function(){ var form=this; var customEvent = document.createEvent("Event"); customEvent.initEvent("lpCustomEvent", true, true); var d = document.getElementById("hiddenlpsubmitdiv"); if (d) {for(var i = 0; i < document.forms.length; i++){ if(document.forms[i]==form){ if (typeof(d.innerText) != 'undefined') { d.innerText=i.toString(); } else { d.textContent=i.toString(); } } } d.dispatchEvent(customEvent); }form.lpsubmitorig2(); } } }}catch(e){}</script></body></html>